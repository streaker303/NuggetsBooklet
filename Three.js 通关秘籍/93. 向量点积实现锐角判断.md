在酷家乐项目里，有这样一个效果：

![2025-06-25 18.23.14.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35f5d43e7f14c2f85b89bd87ff77698~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=12882100&e=gif&f=30&b=f1f4f6)

相机的位置改变的时候，靠近相机的墙会被隐藏。

这种功能是怎么实现的呢？

通过向量点积。

也就是两个向量判断夹角：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/119df0182df94419a67d69e79cc78b74~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1562&h=1144&s=1534527&e=png&b=f3f5f5)

墙的法线向量，相机的方向向量，两者的夹角如果大于 90 度，那就不应该隐藏，否则就应该隐藏。

这个夹角的大小就可以通过向量点积来判断。

这个不只是在酷家乐项目里会用到，其他地方也可能用到，我们单独来学一下。

创建项目：

```
npx create-vite vector-dot
```

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d959297cc4ae4afda3f1af4a9d758c52~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=814&h=620&s=52198&e=png&b=000000)

进入项目，安装依赖：

```
pnpm install
pnpm install --save three
pnpm install --save-dev @types/three
```
改下 src/main.js

```javascript
import './style.css';
import * as THREE from 'three';
import {
    OrbitControls
} from 'three/addons/controls/OrbitControls.js';
import mesh from './mesh.js';

const scene = new THREE.Scene();
scene.add(mesh);

const directionLight = new THREE.DirectionalLight(0xffffff, 2);
directionLight.position.set(500, 400, 300);
scene.add(directionLight);

const ambientLight = new THREE.AmbientLight();
scene.add(ambientLight);

const width = window.innerWidth;
const height = window.innerHeight;

const helper = new THREE.AxesHelper(500);
scene.add(helper);

const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 10000);
camera.position.set(500, 500, 500);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({
  antialias: true
});
renderer.setSize(width, height)

function render() {
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

render();

document.body.append(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
```
创建 Scene、Light、Camera、Renderer。

改下 style.css
```css
body {
  margin: 0;
}
```
创建 mesh.js

```javascript
import * as THREE from 'three';

const group = new THREE.Group();

const origin = new THREE.Vector3( 0, 0, 0 );
const dir = new THREE.Vector3( 1, 2, 0 );
dir.normalize();

const arrowHelper = new THREE.ArrowHelper( dir, origin, 400, 'red' );
group.add( arrowHelper );

const dir2 = new THREE.Vector3( -1, 2, 0 );
dir2.normalize();

const arrowHelper2 = new THREE.ArrowHelper( dir2, origin, 400, 'red' );
group.add( arrowHelper2 );

export default group;
```
指定 orign 和两个点，分别用 ArrowHelper 画两个箭头。

跑起来看一下：

```
npm run dev
```

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6229197111b748c8aef18dfe1d2598d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074&h=402&s=53861&e=png&b=181818)


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d1fdc115a194eb29d09b0057a889cc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1716&h=1056&s=61432&e=png&b=000000)

如何判断这两个向量的夹角是钝角还是锐角呢？

用点积。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d29ec6b474b74ad7a8396517e43c9335~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=502&h=226&s=19399&e=png&b=fefefe)

点积大于 0 就是锐角、否则是钝角。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17412c846e8046f1ad95355ff9d8b149~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1210&h=556&s=91055&e=png&b=1f1f1f)

```javascript
console.log(dir.dot(dir2) < 0 ? '钝角' : '锐角')
```

![25d1cf4a01b81e1b9a667d7f3c8ab8fb.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5c36e19fa994a9582e546959c791727~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1610&h=1020&s=76373&e=png&b=000000)

改一下第二个箭头的方向：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d31e070a67d5481c93f48ea9ce994188~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1282&h=784&s=148105&e=png&b=1f1f1f)

再看下：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4e3d324029f4455b4392a4181efcb78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1764&h=1280&s=113257&e=png&b=000000)

也正确的判断出钝角了。

回到酷家乐的这个效果：

![2025-06-25 18.23.14.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35f5d43e7f14c2f85b89bd87ff77698~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=12882100&e=gif&f=30&b=f1f4f6)

有思路了么？

就是墙的法线向量和相机的方向向量的夹角的判断。

我们也来写一下：

创建 mesh2.js

```javascript
import * as THREE from 'three';

const house = new THREE.Group();

for(let i = 0; i< 4; i ++) {
    const geometry = new THREE.BoxGeometry(500, 300, 20);
    const material = new THREE.MeshLambertMaterial({
        color: 'white'
    });
    const wall = new THREE.Mesh(geometry, material);
    wall.rotateY(Math.PI / 2 * i);
    house.add(wall);
}

house.children[0].position.z = 250;
house.children[1].position.x = 250;
house.children[2].position.z = -250;
house.children[3].position.x = -250;

export default house;
```
画了 4 面墙。

引入下：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1be6ba28b484cb5a3688ede3bc9d28d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=414&s=60701&e=png&b=1f1f1f)


![2025-06-25 19.20.37.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0aef3395dcd341828d7639fce6a74401~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=364243&e=gif&f=15&b=010101)

然后我们就可以得到 4 面墙的法线向量：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52f0279612b04eacb5def7265ba22350~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1994&h=1258&s=171283&e=png&b=000000)

导出这 4 个向量：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6671bf3b468d4359b2ca2786621382fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1036&h=754&s=133479&e=png&b=1f1f1f)

```javascript
export const normals = [
    new THREE.Vector3(0, 0, -1),
    new THREE.Vector3(-1, 0, 0),
    new THREE.Vector3(0, 0, 1),
    new THREE.Vector3(1, 0, 0),
]
```
然后在渲染循环里就可以判断当前相机的方向向量和哪面墙的法线向量夹角是锐角：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbcf5264187140b1ab06db4975e240e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1454&h=906&s=154183&e=png&b=1f1f1f)

```javascript
const dir = camera.getWorldDirection(new THREE.Vector3());
normals.forEach((normal, index) => {
  if(dir.dot(normal) > 0) {
    mesh.children[index].visible = false;
  } else {
    mesh.children[index].visible = true;
  }
});

```
用 camera.getWorldDirection 可以拿到 camera 的方向向量。

和每面墙的法线向量做点积，判断锐角就隐藏。

看下效果：


![2025-06-25 19.33.01.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84adcb536cea42c483083dfaa738516d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=606626&e=gif&f=26&b=000000)

这样就实现了酷家乐同款隐藏靠近相机的墙的功能：

![2025-06-25 18.23.14.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35f5d43e7f14c2f85b89bd87ff77698~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=12882100&e=gif&f=30&b=f1f4f6)

> 案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/vector-dot)

## 总结

这节我们学了通过向量的点积来判断锐角、钝角。

向量 Vector3 的 dot 方法可以计算点积，当点积大于 0，夹角是锐角，反之是钝角。

用 camera.getWorldDirection 可以拿到 camera 的方向向量，用它和墙的法线向量做点积，就可以判断夹角是否是锐角，从而决定隐藏、显示。

向量点积在判断锐角的场景下特别有用，后面也有一些地方会用到。
