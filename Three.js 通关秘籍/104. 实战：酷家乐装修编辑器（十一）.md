上节绘制了一个相对复杂的户型：

![2025-06-24 20.11.49.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e44e72f0d14eeaad3cab8e93effef2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2090&h=1448&s=875963&e=gif&f=28&b=faf5e1)

这节我们继续来把场景优化一下。

首先是地面、天空的颜色：

![2025-06-24 21.23.51.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b17a532913464ccdb7ed4716cf44feb7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2090&h=1448&s=9853726&e=gif&f=54&b=f0f3f5)

地面用 GridHelper 就行，而天空是天蓝色的背景色。

改一下背景色：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de1352e2770c452ea3cee2e705ab56fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=582&s=103274&e=png&b=1f1f1f)


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47843af91b994f51a4c64fc7e382008c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1890&h=1444&s=229722&e=png&b=87cdeb)

加一下地面的 GridHelper：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ea367a97d0344c7a342f2a0095ddfff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1104&h=680&s=104076&e=png&b=1f1f1f)

```javascript
const gridHelper = new THREE.GridHelper(
    100000, 
    500,
    'white',
    'white'
);
gridHelper.position.y = -100;
scene.add(gridHelper);
```
大小为 10w，分成 500 个格子


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6b183981d74a779126ec12d2f69850~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2478&h=1406&s=1356905&e=png&b=8bcfec)

之前房子拿到包围盒的中心之后，y 轴也做了位移，其实没必要。


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df76d6968f024f16acabee90ce905bb0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=612&s=114395&e=png&b=1f1f1f)

![2025-06-24 16.52.45.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404ba5817a2f4e4b8363cc7a91195490~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2090&h=1448&s=11222505&e=gif&f=20&b=81c8e7)

这样 GridHelper 位置就对了。

然后做一下点击时展示线框的效果：

![2025-06-24 17.19.28.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/844a7a224205482788b8f61ef8f91f3e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2090&h=1448&s=7570385&e=gif&f=30&b=edf1f2)

这个用 EdgesGeometry。


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1261ade7e44f2caf7748f70ab5ae49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1558&h=1088&s=279628&e=png&b=1f1f1f)
```javascript
const edges: Array<THREE.Line> = [];
renderer.domElement.addEventListener('click', (e) => {
    const y = -((e.offsetY / height) * 2 - 1);
    const x = (e.offsetX / width) * 2 - 1;

    const rayCaster = new THREE.Raycaster();
    rayCaster.setFromCamera(new THREE.Vector2(x, y), camera);

    const intersections = rayCaster.intersectObjects(scene.children);

    edges.forEach(item => {
        item.parent?.remove(item);
    })
    if(intersections.length) {
        const obj = intersections[0].object as THREE.Mesh;
        if(obj.isMesh) {
            const geometry = new THREE.EdgesGeometry(obj.geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 'blue' 
            });
            const line = new THREE.LineSegments(geometry, material);
            obj.add(line);
            edges.push(line);
        }
    }
});
```
用 edges 数组保存所有的线框。

点击的时候，给点到的对象加一个 EdgesGeometry 的 Line。

之前先把所有的线框删掉，再加一个最新的。

![2025-06-24 17.24.39.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55bd5e742e34d38862425e73ccf14af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2090&h=1448&s=6127464&e=gif&f=45&b=f3f3f3)

这样，线框就加好了。

酷家乐里相机移动的时候，前面的墙会被隐藏：

![2025-06-25 09.50.07.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83c3f879a02342d99bda1456e2072abc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=15263006&e=gif&f=31&b=f0f3f4)

这个是咋做到的呢？

判断角度：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58d610c46565484cbfcfbf7ef7815422~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2368&h=1396&s=1783173&e=png&b=cfebf7)

每面墙都有一条法线。

它和相机方向的夹角，如果是锐角，那就是需要隐藏的，如果是钝角，那就不需要隐藏。

有两个向量 Vector3 可以让它俩做点积，判断是否大于 0 来判断角度。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d29ec6b474b74ad7a8396517e43c9335~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=502&h=226&s=19399&e=png&b=fefefe)

只要知道两个向量的点积可以计算夹角就好了。

首先，我们要在数据里存储一下墙的向量：

首先改下类型：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc7f5947cd624bd0af9a925d7bf790bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&h=556&s=93235&e=png&b=1f1f1f)

```javascript
normal: {x: number, y: number, z: number},
```
然后给每面墙加一下 normal 数据：

向量方向是朝向屋内。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba51a5f00c444ebaa66d6cda027e49fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1812&h=1320&s=1151980&e=png&b=8ccfec)

比如第一面墙的方向就是 { x: 0, y: 0, z: 1 }

这样依次填入每面墙的法线：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f656014b06c4b338b434e3f59327b8d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&h=1038&s=117580&e=png&b=1f1f1f)

```javascript
walls: [
    {
        position: { x: 0, y: 0, z: 0},
        width: 2800,
        height: 3000,
        depth: 200,
        windows: [],
        normal: { x: 0, y: 0, z: 1},
        doors: [
            {
                leftBottomPosition: {
                    left: 1680,
                    bottom: 0
                },
                width: 1000,
                height: 2000
            }
        ]
    },
    {
        position: { x: 0, y: 0, z: 0},
        width: 5000,
        height: 3000,
        depth: 200,
        normal: { x: 1, y: 0, z: 0},
        rotationY: -Math.PI / 2,
        windows: []
    },
    {
        position: { x: -5000, y: 0, z: 5000},
        width: 5000,
        height: 3000,
        depth: 200,
        normal: { x: 0, y: 0, z: 1},
        windows: []
    },
    {
        position: { x: -5000, y: 0, z: 5000},
        width: 1880,
        height: 3000,
        depth: 200,
        normal: { x: 1, y: 0, z: 0},
        rotationY: -Math.PI / 2,
        windows: []
    },
    {
        position: { x: -5200, y: 0, z: 6880},
        width: 3000,
        height: 3000,
        depth: 200,
        normal: { x: 0, y: 0, z: -1},
        windows: [
            {
                leftBottomPosition: {
                    left: 830,
                    bottom: 900
                },
                width: 1200,
                height: 1400
            },
        ]
    },
    {
        position: { x: -2000, y: 0, z: 6880},
        width: 1580,
        height: 3000,
        depth: 200,
        rotationY: -Math.PI / 2,
        normal: { x: 1, y: 0, z: 0},
        windows: []
    },
    {
        position: { x: -2200, y: 0, z: 8260},
        width: 2880,
        height: 3000,
        depth: 200,
        normal: { x: 0, y: 0, z: -1},
        windows: [
            {
                leftBottomPosition: {
                    left: 355,
                    bottom: 0
                },
                width: 2140,
                height: 2400
            },
        ]
    },
    {
        position: { x: 880, y: 0, z: 7080},
        width: 1380,
        height: 3000,
        depth: 200,
        rotationY: -Math.PI / 2,
        normal: { x: -1, y: 0, z: 0},
        windows: []
    },
    {
        position: { x: 880, y: 0, z: 7080},
        width: 2000,
        height: 3000,
        depth: 200,
        normal: { x: 0, y: 0, z: -1},
        windows: []
    },
    {
        position: { x: 2880, y: 0, z: 0},
        width: 7180,
        height: 3000,
        depth: 200,
        rotationY: -Math.PI / 2,
        normal: { x: -1, y: 0, z: 0},
        windows: [
            {
                leftBottomPosition: {
                    left: 1200,
                    bottom: 900
                },
                width: 790,
                height: 1400
            },
            {
                leftBottomPosition: {
                    left: 3680,
                    bottom: 900
                },
                width: 3000,
                height: 1400
            }
        ]
    },
],
```
有了法线之后，每帧渲染的时候就可以计算下夹角了。

我们先把需要用到的墙和相机准备好：



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1f3f00ee8840619c40d468df998468~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1174&h=508&s=93069&e=png&b=1f1f1f)

```javascript
wall.name = 'wall' + index;
```

给墙一个名字，后面好查找。

然后把 camera 导出：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8acdc6653ba4e848c463e49f44f4af7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=870&h=466&s=58547&e=png&b=1f1f1f)

组件里保存下：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a10574d438c440aa9e15b6bf8dc420a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1188&h=730&s=142154&e=png&b=1f1f1f)

```javascript
const camera3DRef = useRef<THREE.Camera>(null);
```
```javascript
camera3DRef.current = camera;
```
然后就可以加一个计算相机和墙夹角的函数了：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c0016e99e34f069f71df6732fbcf57~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1490&h=1332&s=262401&e=png&b=1f1f1f)

```javascript
function wallsVisibilityCalc() {
    const camera = camera3DRef.current!;
    const scene = scene3DRef.current;

    if(!camera) {
        return;
    }
    data.walls.forEach((item, index) => {
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);

        const wallDirection = new THREE.Vector3(item.normal.x, item.normal.y, item.normal.z);

        const obj = scene?.getObjectByName('wall' + index)!;

        if(wallDirection.dot(cameraDirection) > 0) {
            obj.visible = false;
        } else {
            obj.visible = true;
        }

    })
}
```
如果没有 camera 说明没初始化完成，不处理。

遍历墙，通过 camera.getWorldDirection 拿到相机方向，然后和墙的 normal 向量做点积，如果大于 0，说明是锐角，就隐藏，否则显示。

把它传入 init 函数，渲染循环里调用下：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f1b07e0351436c84d2e2cbb17f395e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1492&h=570&s=106492&e=png&b=1f1f1f)

看下效果：

![2025-06-25 10.10.05.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff72310dfbec4f69913a13b97dd6ff7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=17379872&e=gif&f=19&b=82c8e6)

这样我们就实现了酷家乐同款的墙隐藏的效果。

对比下：

![2025-06-25 10.10.50.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/966da83ab40b4dc89b6b79b4dd60c809~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=11444182&e=gif&f=23&b=f0f2f4)

是一样的。

最后我们顺便改一下另一个户型的数据，加上法线：

```javascript
walls: [
    {
        position: { x: 0, y: 0, z: 0},
        width: 5000,
        height: 3000,
        depth: 200,
        normal: { x: 0, y: 0, z: 1},
        windows: []
    },
    {
        position: { x: 0, y: 0, z: 7000},
        width: 5000,
        height: 3000,
        depth: 200,
        normal: { x: 0, y: 0, z: -1},
        windows: []
    },
    {
        position: { x: 0, y: 0, z: 0},
        width: 7200,
        height: 3000,
        depth: 200,
        rotationY: -Math.PI / 2,
        normal: { x: 1, y: 0, z: 0},
        windows: [
                {
                    leftBottomPosition: {
                        left: 2867,
                        bottom: 900
                    },
                    width: 2100,
                    height: 1620
                }
        ]
    },
    {
        position: { x: 5000, y: 0, z: 0},
        width: 7200,
        height: 3000,
        depth: 200,
        rotationY: -Math.PI / 2,
        normal: { x: -1, y: 0, z: 0},
        windows: [],
        doors: [
            {
                leftBottomPosition: {
                    left: 6084,
                    bottom: 0
                },
                width: 856,
                height: 2152
            }
        ]
    },
],
```
试一下：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c8a40648a24858aaa0a9b5c50b3a37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=890&h=314&s=50364&e=png&b=1f1f1f)



![2025-06-25 10.21.09.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acd763b261b84cd48f6b6221b4b3ed20~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=11910041&e=gif&f=17&b=7fc7e6)

也没问题。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/home-decoration-editor)

## 总结

这节我们优化了下 3D 场景。

首先我们改了背景色、加上了 GridHelper 作为地面。

然后点击的时候用 EdgesGeometry 给物体加上了线框。

之后又实现了靠近相机的墙面隐藏的功能。

这个是通过计算墙的向量和相机方向向量的点积来实现的，点积大于 0 代表是锐角。

这样，我们户型的 3D 场景就完成了。

