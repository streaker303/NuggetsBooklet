前面我们都是在 react 项目里用原生 three.js api 来操作 3D 场景。

其实还有一个专门的 react 渲染器叫做 react-three-fiber：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c92274b3da184fcea3dcf0849301838d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672&h=838&s=152751&e=png&b=fefdfd)

它可以用组件的方式来写 3D 场景，和 react 结合更紧密。

比如创建一个 Box 组件：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65901281af0d4bc98e48b005cf828ef1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&h=876&s=154064&e=png&b=f7f7f7)

mesh、geometry、material 都是组件的形式写在 jsx 里。

我们来试一下：

```
npx create-vite react-three-fiber-test
```

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941a6e351cbd4945bab249dd5ac7cfa8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=618&s=58358&e=png&b=000000)

创建 vite + react 的 js 项目。

进入项目，安装依赖：

```
pnpm install
pnpm install --save three
pnpm install --save-dev @types/three
```

然后安装 react-three-fiber

```
pnpm install --save @react-three/fiber
```
去掉 index.js 和 StrictMode

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59755a5278c5415e90555c0ec8ab2142~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=866&h=588&s=85787&e=png&b=1f1f1f)

改下 App.jsx

```javascript
import { OrbitControls } from '@react-three/drei'
import { Canvas } from '@react-three/fiber'

function App() {
  return <Canvas camera={{
    position: [0, 500, 500]
  }} style={{
      width: window.innerWidth,
      height: window.innerHeight
  }}>
    <ambientLight/>
    <axesHelper args={[1000]}/>
    <directionalLight position={[500, 400, 300]}/>
    <OrbitControls/>
    <mesh>
      <dodecahedronGeometry args={[100]}/>
      <meshPhongMaterial color={'orange'}/>
    </mesh>
  </Canvas>
}

export default App
```
threejs 场景会渲染到 canvas 上，所以我们用 Canvas 作为根组件。

canvas 指定宽高为窗口宽高。

指定 camera 的位置。

创建一个环境光，一个平行光。

加一个 axesHelper，参数在 args 里通过数组传入。

然后加一个 OrbitControls。

场景里加一个 mesh，mesh 的子组件指定 geometry 和 material。

这里我们创建了一个十二面体。

注意，这里 OrbitControls  是从 @react-three/drei 这个包导入的，扩展的一些 api 都放在这个包里。

```
pnpm install --save @react-three/drei
```
跑下试试：

```
npm run dev
```

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45b8fceb88d84a83aaaf41da98006adc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1268&h=392&s=47803&e=png&b=181818)


![2025-07-10 12.09.28.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a2a1032bec4bfdb327cc06f85ced26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2812&h=1514&s=318407&e=gif&f=17&b=fefefe)

这样，3D 场景就绘制出来了。

如果你熟悉 threejs 的原生 api，切换到 react-three-fiber 也很快就能上手了。

但我们之前写代码是有渲染循环的：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d38d46a35c14a33bc373e7b2a01b59c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=724&h=342&s=42604&e=png&b=202020)

现在如果想在渲染循环里执行一些逻辑怎么办呢？

react-three-fiber 提供了一个 hook，叫 useFrame

它的作用就是每次渲染循环执行一些逻辑。

加一下试试；

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23fa698f52524b1fb1fa3c5ba662724d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1254&h=1108&s=182353&e=png&b=1f1f1f)

用 useRef 拿到 mesh 的 ref，每一帧渲染改变一下 rotation.y

```javascript
import { OrbitControls } from '@react-three/drei'
import { Canvas, useFrame } from '@react-three/fiber'
import { useRef } from 'react';

function App() {

  const meshRef =  useRef();

  useFrame((state, delta) => {
    meshRef.current.rotation.y += 0.1;
  });

  return <Canvas camera={{
    position: [0, 500, 500]
  }} style={{
      width: window.innerWidth,
      height: window.innerHeight
  }}>
    <ambientLight/>
    <axesHelper args={[1000]}/>
    <directionalLight position={[500, 400, 300]}/>
    <OrbitControls/>
    <mesh ref={meshRef}>
      <dodecahedronGeometry args={[100]}/>
      <meshPhongMaterial color={'orange'}/>
    </mesh>
  </Canvas>
}

export default App
```
跑起来之后控制台报错了：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96d7518d6bda480ab0c90514391f4ab6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=766&h=190&s=38742&e=png&b=fceded)

useFrame 只能用在 Canvas 的子组件里。

我们把 mesh 封装一下：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9497a74e9acd400c9cbbca02c0d8100a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1192&h=1034&s=168466&e=png&b=1f1f1f)

```javascript
import { OrbitControls } from '@react-three/drei'
import { Canvas, useFrame } from '@react-three/fiber'
import { useRef } from 'react';

function Mesh() {
  const meshRef =  useRef();

  useFrame((state, delta) => {
    meshRef.current.rotation.y += 0.1;
  });

  return <mesh ref={meshRef}>
    <dodecahedronGeometry args={[100]}/>
    <meshPhongMaterial color={'orange'}/>
  </mesh>
}

function App() {
  return <Canvas camera={{
    position: [0, 500, 500]
  }} style={{
      width: window.innerWidth,
      height: window.innerHeight
  }}>
    <ambientLight/>
    <axesHelper args={[1000]}/>
    <directionalLight position={[500, 400, 300]}/>
    <OrbitControls/>
    <Mesh/>
  </Canvas>
}

export default App
```
封装 Mesh 组件，在里面调用 useFrame

看下效果：


![2025-07-10 16.36.43.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35670a0e3ab748dd8c44ea9c594fa912~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2812&h=1514&s=140176&e=gif&f=16&b=fefefe)

这样就好了。

而且用了 react-three-fiber 之后处理鼠标事件就更简单了。

之前是这样写：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e88a4389a6d2480587003d5374c58699~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1108&h=346&s=84145&e=png&b=1f1f1f)

用 RayCaster 发出一条射线，判断和对象是否相交。

而现在只需要这样写：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f086ddcd0d354a2e86d756d89303fad0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1328&h=908&s=155586&e=png&b=1f1f1f)

```javascript
function clickHandler() {
    meshRef.current.material.color.set('blue');
}
```
```javascript
onClick={clickHandler}
```
绑定事件写起来和 dom 是不是一模一样？

react-three-fiber 帮你封装好了，不需要自己调用 RayCaster 的 api。

试一下：


![2025-07-10 16.46.45.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2f443c6bf364fe79ee4ca6fcd6f0cd1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2812&h=1514&s=109761&e=gif&f=11&b=fefefe)

我们写 3D 场景，经常需要加载 gltf 模型，在 react-three-fiber 里也有对应的 hook：useLoader

试一下：

从 sketchfab.com 找个模型：

https://sketchfab.com/3d-models/naruto-shippuden-naruto-ea2e5dff481243b9973f2bb34a384031


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea8a7debbfd94d13b4cbf060e95c7cec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2432&h=1330&s=1802181&e=png&b=1f1f1f)

下载下来放到 public 目录下：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f3dbddc329f46de91fade87907e96b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=540&h=332&s=22847&e=png&b=1a1a1a)

代码里用一下：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d33bb22be29340509c5dac5edc1fabd6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1302&h=964&s=153291&e=png&b=1f1f1f)

```javascript
<Suspense fallback={null}>
  <Naruto/>
</Suspense>
```
```javascript
function Naruto() {
  const gltf = useLoader(GLTFLoader, 'naruto.glb')
  console.log(gltf);

  gltf.scene.scale.setScalar(200);
  return <primitive object={gltf.scene}/>
}
```
Suspense 是 React 内置组件，用于异步加载子组件。

这样当渲染这个组件的时候才会去下载模型。

看一下：


![2025-07-10 17.05.20.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfc9a387e23c4cf09927b6c167fc617b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2116&h=1128&s=704060&e=gif&f=22&b=fefefe)

这样，模型就加载进来了。

此外，还有一个 hook 也可能用到，就是 useThree

之前我们用 useFrame 的时候，第一个参数 state 就可以拿到 camera、controls 这些上下文信息：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/718c52359fe74e39831609ccd23b3b6e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=838&h=674&s=77581&e=png&b=202020)

useThree 就是拿到这个上下文：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d225ca4c8bc54ead9ea52440f593113a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1292&h=952&s=147942&e=png&b=1f1f1f)

```javascript
const size = useThree(state => state.size);
console.log(size);

const camera = useThree(state => state.camera);
gsap.to(camera.position, {
    x: 0,
    y: 500,
    z: 200,
    duration: 1
});
```
比如用 useThree 拿到 canvas 的 size


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fdfe08e3e74e269676686c7702c752~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1350&h=628&s=170636&e=png&b=fefdfd)

或者拿到 camera 做个相机动画。

这里用到了 gsap 做缓动动画，安装下：

```
pnpm install --save gsap
```

![2025-07-10 17.17.24.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6260de1322834219887a5d2db2db13b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2116&h=1128&s=280531&e=gif&f=15&b=ffffff)

这样，react-three-fiber 的各种 api 我们就都会用了。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/react-three-fiber-test)

## 总结

这节我们学了下 react-three-fiber，它是用组件的方式来写 3D 场景。

核心 api 在 @react-three/fiber 这个包，扩展的 api 比如 OrbitControls 在 @react-three/drei 这个包。

最外层根组件是 Canvas，其余的 light、mesh 等都用组件的方式写。

我们用了 useLoader、useThree、useFrame 这几个 hook：

- useFrame：在每帧的渲染循环里执行一些逻辑，可以通过第一个参数 state 拿到上下文
- useLoader： 加载 gltf 模型，结合 react 的 Suspense 组件实现异步加载
- useThree：拿到 state 上下文，比如 size、camera 等。

而且 mesh 绑定点击事件等直接写 onClick 就行，不用自己调用 RayCaster 的 api，r3f 内部做了封装。

用组件的方式来写 3D 场景，确实更符合 react 的开发习惯，有 three.js 和 react 基础，上手还是很快的。
