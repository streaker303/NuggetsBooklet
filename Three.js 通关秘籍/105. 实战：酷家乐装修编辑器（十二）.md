3D 部分的户型绘制告一段落：

![2025-06-25 10.10.05.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff72310dfbec4f69913a13b97dd6ff7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=17379872&e=gif&f=19&b=82c8e6)

这节我们来绘制 2D 部分。

也就是这个：


![2025-06-25 10.45.14.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/166d4c5d27794da3851074c911ab6864~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=4298070&e=gif&f=31&b=f1f4f4)

它是在一个平面上绘制，其实不是非得用 threejs，用任何 canvas 技术都行，比如 fabric.js。

我们维护的同一份数据，在 3D 视图用 threejs 绘制 3D 场景，在 2d 视图可以用别的技术方案来绘制平面户型。


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a27a8ed9b744f7480454d8591f583e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=810&h=440&s=26380&e=png&b=ffffff)

先来绘制这个户型：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/825bdd067f5040c7aaab87e242525582~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1872&h=1070&s=916378&e=png&b=8ed0ec)

改下 init-2d.ts，加上坐标轴 helper、调一下灯光位置（和 3d 场景一样，灯光从上往下）。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51ecaff5c9bb4306ab8fb89106db2967~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=498&s=103335&e=png&b=1f1f1f)

然后先用之前 3d 场景渲染墙的方式渲染一下试试：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d124bd3303294004bf7d770268f4bd0b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1636&h=1396&s=316920&e=png&b=1f1f1f)

```javascript
useEffect(() => {
    const scene = scene2DRef.current!;
    const house = new THREE.Group();
    const walls = data.walls.map((item, index) => {
        const shape = new THREE.Shape();
        shape.moveTo(0,0);
        shape.lineTo(0, item.height);
        shape.lineTo(item.width, item.height);
        shape.lineTo(item.width, 0);
        shape.lineTo(0, 0);

        const geometry = new THREE.ShapeGeometry(shape);
        const material = new THREE.MeshPhongMaterial({
            color: 'white'
        })
        const wall =  new THREE.Mesh(geometry, material);
        wall.position.set(item.position.x, item.position.y, item.position.z);

        if(item.rotationY) {
            wall.rotation.y = item.rotationY;
        }
        wall.name = 'wall' + index;
        return wall;
    });

    house.add(...walls);
    scene.add(house);
}, [data]);
```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2bff6649d84414f8e368ee90240a404~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2152&h=1514&s=86626&e=png&b=b2d9e7)

可以看到，之前我们 3D 场景里是竖直画的墙，现在 2D 里就不对了。

所以要改下：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9fa3fd441e74ab1bdebb881c9a1a99e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1616&h=1422&s=306227&e=png&b=1f1f1f)

```javascript
useEffect(() => {
    const scene = scene2DRef.current!;
    const house = new THREE.Group();
    const walls = data.walls.map((item, index) => {
        const shape = new THREE.Shape();
        shape.moveTo(0,0);
        shape.lineTo(0, item.depth);
        shape.lineTo(item.width, item.depth);
        shape.lineTo(item.width, 0);
        shape.lineTo(0, 0);

        const geometry = new THREE.ShapeGeometry(shape);
        const material = new THREE.MeshPhongMaterial({
            color: 'white',
            side: THREE.DoubleSide
        })
        const wall =  new THREE.Mesh(geometry, material);
        wall.position.set(item.position.x, item.position.y, item.position.z);

        if(item.rotationY) {
            wall.rotation.y = item.rotationY;
        }
        wall.name = 'wall' + index;
        wall.rotateX(-Math.PI / 2);
        return wall;
    });

    house.add(...walls);
    scene.add(house);
}, [data]);
```
之前 height 的地方改成 depth，然后旋转一下。

并且调节下相机的位置、可视范围：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34fcfbee092c4eb4818f5761cea24092~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1452&h=262&s=63691&e=png&b=1f1f1f)

```javascript
const camera = new THREE.PerspectiveCamera(60, width / height, 1, 100000);
camera.position.set(0, 10000, 0);
camera.lookAt(0, 0, 0);
```

坐标轴有点短，调大一点：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2567baebc3c45b2b7c68c3b1795747c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2000&h=1212&s=56048&e=png&b=add9e6)


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e9760a29bd641d4a603ebfe2b1b7a52~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1060&h=294&s=57258&e=png&b=1f1f1f)


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a6d45f119bd4d53b4dcc0e85ec164b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1856&h=1296&s=69260&e=png&b=add9e6)

我们同样用包围盒计算中心点，让房子的中心移动到原点：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f447ff8c90a48e9bae826c2c5e9e934~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158&h=484&s=86243&e=png&b=1f1f1f)

```javascript
const box3 = new THREE.Box3();
box3.expandByObject(house);

const center = box3.getCenter(new THREE.Vector3());
house.position.set(-center.x, 0, -center.z);
```

![2025-06-25 12.08.03.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d898ab659283401a838e2c5028384a7a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=669436&e=gif&f=16&b=a3d1e1)

然后旋转角度还要调一下。

绕 Y 轴旋转一定的角度，这里用 MathUtils 来做角度转弧度：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/424a7e686ef94b3092568919be8df090~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=640&s=126484&e=png&b=1f1f1f)

```javascript
const rad = THREE.MathUtils.degToRad(26);
house.rotateY(rad);
```


![2025-06-25 12.09.19.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc67884016e247878d9f8474ebcb640f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=651865&e=gif&f=19&b=a3d1e1)

现在角度就对了。


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/210b11d475844631aa2f014427933a72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1434&h=1002&s=44145&e=png&b=add9e6)

当然，这里有一些凸出来的地方，这个问题下节统一解决，这里先不管。

我们继续绘制地板：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1d3d4f90f87478badbc1abcc9298a7a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1414&h=1350&s=295787&e=png&b=1f1f1f)

这部分就和前面 3D 场景里的一样了。

```javascript
const floors = data.floors.map(item => {
    const shape = new THREE.Shape();
    shape.moveTo(item.points[0].x, item.points[0].z);
    for(let i = 1; i < item.points.length; i++) {
        shape.lineTo(item.points[i].x, item.points[i].z);
    }

    let texture = floorTexture;
    if(item.textureUrl) {
        texture = textureLoader.load(item.textureUrl);
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.wrapS =  THREE.RepeatWrapping;
        texture.wrapT =  THREE.RepeatWrapping;
        texture.repeat.set(0.002, 0.002);
    }

    const geometry = new THREE.ShapeGeometry(shape);
    const material = new THREE.MeshPhongMaterial({
        map: texture,
        side: THREE.BackSide
    });
    const floor = new THREE.Mesh(geometry, material);
    floor.rotateX(Math.PI / 2);
    return floor;
});
house.add(...floors);
```


![2025-06-25 12.17.19.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a615f216d57a45ea8fed20179cfc89e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=3349713&e=gif&f=18&b=a4d1e2)

可以看到，绘制出来了。

但绘制的有一点误差，这个下节统一解决。

我们切换到另一个户型：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e4f4f43227c4ae4b3279697cfc2b174~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=924&h=276&s=44126&e=png&b=1f1f1f)


![2025-06-25 12.20.44.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13cf2e7e129044ddaa8c1aa8a98b3cc9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=2679788&e=gif&f=38&b=a3d1e1)

整体户型的墙、地板也都绘制出来了。

不过也是以为之前绘制的问题，这里有点不准。

先不着急继续绘制门窗，我们下节统一把这个问题解决一下。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/home-decoration-editor)


## 总结

这节我们实现了 2D 平面的绘制。

同一份数据，使用 2D 平面绘制，把 ExtrudeGeometry 换成 ShapeGeometry 来绘制就可以了。

用包围盒计算了大小，调整房子中心位置到坐标原点，然后用 MathUtils 做了角度转弧度，之后旋转了下。

这样整体户型就画出来了，不过因为绘制的有点问题，看起来有误差，下节我们统一解决。

