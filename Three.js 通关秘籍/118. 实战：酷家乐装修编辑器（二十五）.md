上节实现了拖拽家具列表中的家具到房子的任意位置：

![2025-07-25 19.42.20.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/376965e3e0f84da4b77601a1949c446b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=3770634&e=gif&f=37&b=f6f6f6)

有两个问题：

- 因为我们去掉了房子位置的修改，现在相机的焦点不是房子中心
- 现在是写死的家具，并不是拖拽不同家具就添加对应的家具

我们先来解决第一个问题。

如何让相机的焦点在房子中间呢？

其实有两种方案：

第一种就是用 Box3 包围盒拿到房子大小，然后修改房子位置到 0,0,0 就好了，相机焦点默认在 0,0,0

另一方方案是房子位置不变，修改相机的焦点为房子的中心位置。

第一种方式之前用过，现在我们用修改相机焦点的方式再来实现这个功能。

要注意的是，相机的焦点 camera.lookAt 要和 OrbitControls 的 target 同时修改才行。

所以我们这里导出 OrbitControls：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e46614963c044849e86dc7acea6984b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=874&h=510&s=58000&e=png&b=1f1f1f)

组件里接收下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e235ec68eb242f1a87fb37cd509cae1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1416&h=652&s=195269&e=png&b=1f1f1f)

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3727f5523e94a4da0799e1e2db762d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1346&h=664&s=113508&e=png&b=1f1f1f)
```javascript
const controls3DRef = useRef<OrbitControls>(null);
```
```javascript
controls3DRef.current = controls;
```
然后在之前修改房子位置的地方改成修改相机焦点位置：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26072e6dfaae4bfba06a0e0ad52974c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1280&h=500&s=94210&e=png&b=1f1f1f)

```javascript
camera3DRef.current?.lookAt(center.x, 0, center.z);
controls3DRef.current?.target.set(center.x, 0, center.z);
```
试一下：

之前是这样：


![2025-07-25 19.54.24.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad81b5b6abb94a45850a2f4ae8965c07~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=4822590&e=gif&f=18&b=f4f4f4)

现在是这样：

![2025-07-25 19.54.55.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804c4a18559c4815801b5a045424aaed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=5788436&e=gif&f=21&b=f3f3f3)

现在相机焦点又移到房子中央了，但这次不是在 0,0,0 的位置。

添加家具的功能正常：

![2025-07-25 19.56.05.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a52a659c5b4ce2b558ac4722c3cecb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=890951&e=gif&f=22&b=f1f1f1)

然后来解决拖拽不同家具的对应处理。

这个其实就是在 useDrag 里加一个上下文数据就行：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8f6d5d327644d388638f496d84fe98b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1560&h=836&s=120468&e=png&b=1f1f1f)
```javascript
const [, drag]= useDrag({
    type: '家具',
    item: {
        modelUrl: props.title === '床' ? './bed.glb' : './dining-table.glb'
    },
});
```
item 就是这个上下文数据。

然后在 useDrop 的时候，就直接用这个 url 来加载模型：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fd4a6609267403c8ee3fcf091d60411~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1438&h=1362&s=285504&e=png&b=1f1f1f)

```javascript
item: { modelUrl: string }
```
```javascript
modelUrl: item.modelUrl
```
还要处理下 scale 的问题：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4b10209af544c5e9bd5946d06b766d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1560&h=792&s=98839&e=png&b=1f1f1f)

```javascript
modelScale: item.modelUrl.includes('bed.glb') ? 800 : 1,
```
试一下：

清空两个户型的默认家具：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8f19d243ca4c07a34a6a838339dbba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1152&h=1226&s=169543&e=png&b=1f1f1f)

然后切换户型：


![2025-07-25 21.20.22.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cb0f4a867ca4f4c910d1d9f9f9814a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=1814747&e=gif&f=38&b=f4f4f4)


![2025-07-25 21.20.48.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37b460414134e138bf4f0db8ce0560c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=12041780&e=gif&f=50&b=efefef)

这样，拖拽家具到 3D 场景中就完成了。

不过 2D 视图没有同步更新。

和之前同样的问题：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd557d6e88a94f6ba32e5736d9443663~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1626&h=1318&s=231545&e=png&b=1f1f1f)

加上 else 的处理，注意 2D 视图位置是反的。

```javascript
else {
    const gltfLoader = new GLTFLoader();
    const furnitures = houseObj.getObjectByName('furnitures')!;

    gltfLoader.load(furniture.modelUrl, (gltf) => {
        furnitures.add(gltf.scene);

        gltf.scene.scale.setScalar(furniture.modelScale || 1);

        gltf.scene.position.set(
            -furniture.position.x,
            -furniture.position.y,
            -furniture.position.z
        );

        gltf.scene.rotation.x = furniture.rotation.x;
        gltf.scene.rotation.y = furniture.rotation.y;
        gltf.scene.rotation.z = furniture.rotation.z;

        gltf.scene.traverse(obj => {
            (obj as any).target = gltf.scene;
        });
        gltf.scene.name = furniture.id
    });
}
```
顺便把坐标轴都去一下：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/593c64f5095243089da363baa8f947a1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=974&h=276&s=49404&e=png&b=1f1f1f)


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b502b0bd34974219ad1765d2c6fd5bef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=336&s=54721&e=png&b=1f1f1f)


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742a55be038c4e4c9d7c8a243c24a0ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1008&h=372&s=47362&e=png&b=1f1f1f)

看下效果：

![2025-07-25 21.42.13.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d607328fd6a4414a54ba22988759714~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=2411304&e=gif&f=50&b=f4f4f4)

![2025-07-25 21.44.17.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95f396b153448eda988fa1d9e101de2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2804&h=1484&s=3711043&e=gif&f=50&b=f3f3f3)

这样，拖拽家具到 3D 场景的功能就完成了。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/home-decoration-editor)

## 总结

这节我们修复了两个问题。

第一个是相机焦点设置到房子中心的问题，这个可以移动房子位置，也可以移动相机焦点，我们用的第二种方案，设置 camera.lookAt 和 controls.target 

第二个是拖拽不同家具的时候，添加对应家具的功能，这个是在 useDrag 的时候通过 item 传递数据，然后 useDrop 的时候取出 item 加载对应模型就好了。

当然，目前我们只实现了拖拽家具到 3D 视图，2D 视图也是可以实现拖拽的，原理一样。
