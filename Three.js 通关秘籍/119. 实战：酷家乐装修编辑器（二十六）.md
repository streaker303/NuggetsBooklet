上节实现了拖拽家具到 3D 场景：

![2025-07-25 21.42.13.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d607328fd6a4414a54ba22988759714~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=2411304&e=gif&f=50&b=f4f4f4)

这节我们压缩一下模型。

因为我在 push 代码的时候，提示我模型文件超过 100M 了：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d79bd64bf48c41d9b22233273d0b1bd0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2522&h=274&s=209451&e=png&b=1b1b1b)

我们用 draco 来压缩下。

前面讲过，可以用 gltf-pipeline 来做这个。

我们模型是从这里下载的：

https://sketchfab.com/3d-models/bed-52da52f882e242aba646980e9757ef9f#download


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538c6b0bcdab481e974d00d69b5ef675~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2038&h=1244&s=1422978&e=png&b=ececec)

是 120M 左右：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a617ddbb52694e5e80f76e3b43cf5023~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&h=582&s=78579&e=png&b=fbfbfb)

然后我们用 gltf-pipeline 压缩下：

```
npx gltf-pipeline -i ./public/bed.glb -o ./public/bedDraco.glb -d
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e513251116b749c69cdff01335ee5f44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1314&h=166&s=19483&e=png&b=181818)

压缩后只有 50M 左右了：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98ad941e34554e2889b698f53abd1e03~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=598&s=82039&e=png&b=fbfbfb)

小了一半多。

但这样运行时就需要用 DracoLoader 来解压缩了，相当于用时间换空间。

加载快了，但是需要一段解压的时间。

把之前的 bed.glb 删掉，把压缩后的 bedDraco.glb 改名为 bed.glb


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f0d972cbace4a96aade20e26b8a9920~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=854&h=612&s=78959&e=png&b=fbfbfb)

然后跑一下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b323b8335443c1bc9f527e12eeb4b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1738&h=774&s=302537&e=png&b=f2efef)

可以看到，报错说是没提供 DracoLoader

我们加一下：

我们代码里一共 new 过 6 个 GLTFLoader，现在统一提取一下：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/251d081935ee4611a00e540749ab7629~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1814&h=698&s=163092&e=png&b=1f1f1f)

```javascript
let loaderCache: GLTFLoader;
function getGLTFLoader() {
    if(!loaderCache) {
        const gltfLoader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath( 'https://www.gstatic.com/draco/versioned/decoders/1.5.6/' );
        gltfLoader.setDRACOLoader(dracoLoader);
        loaderCache = gltfLoader;
    }
    return loaderCache;
}
```
加一个变量来缓存，如果创建过就直接返回，这样全局就一个 GLTFLoader。

指定 DracoLoader，并且设置一个 draco 包的下载地址。

然后替换下代码里的 new GLTFLoader

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2b5e2d6753841f7897b8f474bf01ab0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=514&s=57203&e=png&b=202020)

除了第一个，其余的全部替换。

再跑下：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f6b6544ca7f40e2aba646a228f5000d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2268&h=1502&s=881645&e=png&b=f4f4f4)

现在床的模型就加载出来了。

但你可以明显感觉到模型加载比之前慢了。

这是之前的加载速度：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/190c20d4fcf445bead023c95e1899e09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1356&h=426&s=117241&e=png&b=fdfdfd)

这是现在的：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb2187c40785413fa261fdeb7db54822~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078&h=450&s=89516&e=png&b=fefefe)

加载速度是快了一倍，但渲染出来等的更久了。

这就是因为用 draco 压缩之后，运行时解压需要时间。

我们之前的写法每次用到模型都会单独加载，这样每次都要单独下载这个模型文件，然后解压缩。

这样显然是性能很差的。

所以我们要在页面加载的时候统一加载模型，模型加载完之后，就直接用，渲染的时候不再加载模型。

其实酷家乐的也是这样：

![2025-07-27 18.06.41.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a1d9ee1be3342209dce6c7299fdb659~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2804&h=1484&s=2588340&e=gif&f=29&b=f2f2f4)

模型加载完之后再进入。

把这个方法导出下：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0a8091bcd2d4e359878ea361e18ec27~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=576&s=109670&e=png&b=1f1f1f)

然后在 App.tsx 加一下 loading：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45b913d852384cc98abdbae3ac9aa433~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1392&h=1390&s=245530&e=png&b=1f1f1f)

就是用一个 map 来保存，key 是路径，value 是加载模型的 promise

然后 App 组件里加一个 useState 记录加载  modelLoaded 状态。

用 Promise.all 在所有模型加载完之后设置  modelLoaded 状态。

根据 modelLoaded 状态来切换界面和 loading

```javascript
import './App.scss'
import Header from './components/Header';
import Menu from './components/Menu';
import Main, { getGLTFLoader } from './components/Main';
import Properties from './components/Properties';
import { useEffect, useState } from 'react';

const gltfLoader = getGLTFLoader();

export const modelMap = {
  './bed.glb': gltfLoader.loadAsync('./bed.glb'),
  './dining-table.glb': gltfLoader.loadAsync('./dining-table.glb'),
  './door.glb': gltfLoader.loadAsync('./door.glb'),
  './window.glb': gltfLoader.loadAsync('./window.glb')
}

function App() {
  const [modelLoaded, setModelLoaded] = useState(false);

  useEffect(() => {
    Promise.all(Object.values(modelMap)).then(() => {
      setModelLoaded(true);
    })
  }, []);

  return <div>
      {
        modelLoaded ? 
          <div className='wrap'>
            <Header />
            <div className='editor'>
              <Menu/>
              <Main/>
              <Properties/>
            </div>
          </div>
          : <div>
            <p>loading...</p>
          </div>
      }
    </div>
}

export default App
```
试一下：


![2025-07-27 18.25.18.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f2a25ab91d149bfa3e8826d30506b7c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2804&h=1484&s=935967&e=gif&f=20&b=acd4e3)

确实是在 loading 之后进入的界面。

我们打开 devtools 搜一下  glb 文件：

![2025-07-27 18.30.24.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7df1590507d64319a6368da576133c9d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2776&h=1132&s=913769&e=gif&f=41&b=fcfcfc)

可以看到是下载完 glb 模型之后再渲染的界面。

先给 modelMap 加一下类型：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc50a54936bd4c2cbd88f6c33c67e421~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1350&h=662&s=170543&e=png&b=1f1f1f)

```javascript
Record<string, Promise<GLTF>>
```

整体是一个 Record 键值对类型，key 是 string，value 是 Promise\<GLTF> 类型。

然后我们把后面用的模型改成这里的。

先改一下家具的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86816fd6b15a4e4abb7892492bfd6ab0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1400&h=1290&s=212905&e=png&b=1f1f1f)
    
就是把之前 gltfLoader.load 换成直接从 modelMap 里取。

```javascript
modelMap[furniture.modelUrl].then(gltf => {  
```
搜一下，其余几处也是这样改：
    
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba0e3c8a11f0478899b06806d260bfe4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1416&h=848&s=134771&e=png&b=202020)
    

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e39264ac46142f7a37be6e7d689139b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1208&h=798&s=138806&e=png&b=1f1f1f)
    
    
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/289b1642131441ca873bf4f5fcd6f986~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1096&h=674&s=108957&e=png&b=202020)

看下效果：
    

![2025-07-27 18.41.53.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89f926f3b11746fb81963c7c83f6d15b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2736&h=1534&s=1107327&e=gif&f=20&b=aad1e2)
    
可以看到，家具模型全程只渲染了一次。
    
这里我们要 clone 一下，不然都是同一个。
    

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a5ee4926034dbaa214b47067d566ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=560&s=107706&e=png&b=202020)
    
    
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5251e8f584814626a1d19558f91c958b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1002&h=622&s=106349&e=png&b=202020)
    

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84900dd509d049f1a98abe55a29c9e05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1188&h=764&s=131768&e=png&b=202020)
    

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398780c841304b43a9b11e658b9b3b72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074&h=620&s=106984&e=png&b=202020)
    
4 处都改一下。
    
再看下：


![2025-07-27 18.48.17.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aff35c9fca4340528f694f8ece9ff6e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2736&h=1534&s=1363553&e=gif&f=22&b=a9d1e2)

这样，模型就都出来了。

然后再改下门窗的：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ed80d771008415fa458279479a9f80d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1174&h=1068&s=213286&e=png&b=1f1f1f)

```javascript
const gltf = await modelMap['./window.glb'];
```
```javascript
const gltf = await modelMap['./door.glb'];
```
同样是只渲染了一个：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9b281a4f83f45578415afaa74687a9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1912&h=998&s=745289&e=png&b=efefef)


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53e60de70a164ef1ae6caa2a0cb0a0d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1198&h=1094&s=196861&e=png&b=1f1f1f)

```javascript
gltf.scene = gltf.scene.clone();
```

![2025-07-27 18.52.10.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67281352d2a141c6b43fcde29b6d0db3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2736&h=1534&s=5606275&e=gif&f=21&b=f4f4f4)

现在就好了。

打开 devtools 看下：


![2025-07-27 18.53.06.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cefba287c7e4883b6569e746c32cf9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2736&h=1534&s=1661569&e=gif&f=48&b=f9f9f9)

可以看到，现在全部加载完 4个模型才渲染界面，并且之后再也没加载过模型。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/home-decoration-editor)


## 总结

这节我们优化了下性能。

首先用 gltf-pipeline 对一些模型进行了压缩，运行时用 DracoLoader 解压

然后加了 loading，最开始加载全部模型，等模型都加载完之后再渲染，并且之后不再加载模型。

这样改造下来，加载模型的速度，以及后续的操作体验都会好很多。
