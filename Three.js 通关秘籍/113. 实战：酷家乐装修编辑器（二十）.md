上节把编辑后的家具数据保存到了 store 并做了持久化：

![2025-06-29 21.02.43.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fb3bbf2b2df4eda90102a3449d0ee62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=1097552&e=gif&f=43&b=f4f4f4)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3de61264837b4f66b9172a1966ea7b08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1302&h=1100&s=187286&e=png&b=fefefe)

这节我们在 2D 视图把它绘制出来。

我们把 2D 的坐标轴辅助线加长一下：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fc999991264aacacd4e668208d1346~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=392&s=82427&e=png&b=1f1f1f)


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d35ff6d0ab6342b39fbfa930b4023d2d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1608&h=1258&s=394222&e=png&b=add8e5)

家具是添加到 house 里的，我们也可视化一下 house 的局部坐标系：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c03d8b0bb9546d499c8b926785378d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1242&h=744&s=164520&e=png&b=1f1f1f)

```javascript
const helper = new THREE.AxesHelper(30000);
house.add(helper);
```


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2107933551be4d9583432a5671985a3e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1532&h=1152&s=387787&e=png&b=add9e6)

可以看到，house 的局部坐标系。

家具是添加到 house 下的，位置是相对这个局部坐标系做偏移。

这个忘了的同学可以回顾下局部坐标、世界坐标那一节。

然后就可以绘制家具了：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3f15f8d7a8c47c7b01b6cdd9ca5cce0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1346&h=1202&s=244463&e=png&b=1f1f1f)

```javascript
const furnitures = new THREE.Group();
furnitures.name = 'furnitures';
data.furnitures.forEach(furniture => {
    const gltfLoader = new GLTFLoader();
    gltfLoader.load(furniture.modelUrl, (gltf) => {
        furnitures.add(gltf.scene);

        gltf.scene.position.set(
            furniture.position.x,
            furniture.position.y,
            furniture.position.z
        );

        gltf.scene.rotation.x = furniture.rotation.x;
        gltf.scene.rotation.y = furniture.rotation.y;
        gltf.scene.rotation.z = furniture.rotation.z;

        gltf.scene.traverse(obj => {
            (obj as any).target = gltf.scene;
        });
        gltf.scene.name = furniture.id;
    });
})
house.add(furnitures);
```
看下效果：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be284c543344a7398b49e8ee20ae10f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2086&h=1438&s=529917&e=png&b=add8e5)

家具绘制出来了，但是位置不对，放到它的镜像位置刚刚好。

这个是我们之前调整墙的绘制问题的时候，统一给位置都设置了相反数。

所以家具的位置也是相反数。


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c82697829949abb78e5d7866382884~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1130&h=566&s=95960&e=png&b=1f1f1f)


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de9e8c694524d29b89fdbf031f57137~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=1228&s=453992&e=png&b=add7e4)

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51ea925804e84b409752322f6f3b2a8a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1950&h=1290&s=1104841&e=png&b=f2f2f2)

这样就对了。

然后更新的时候也是同样的逻辑：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0c0eeccfe5494db4f387e305794927~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1490&h=1242&s=234380&e=png&b=1f1f1f)

```javascript
const houseObj = scene.getObjectByName('house')!;
if(houseObj) {

    data.furnitures.forEach(furniture => {
        const obj = houseObj.getObjectByName(furniture.id);

        if(obj) {
            obj.position.set(
                -furniture.position.x,
                -furniture.position.y,
                -furniture.position.z
            );

            obj.rotation.x = furniture.rotation.x;
            obj.rotation.y = furniture.rotation.y;
            obj.rotation.z = furniture.rotation.z;
        }
    })
    return;
}
```
试一下：


![2025-07-02 14.33.27.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc561b7e35e640cebd5fa842751b0cc9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=4586461&e=gif&f=37&b=e6f3fb)

没啥问题。

不过家具没必要 y 轴方向编辑，改一下：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/969e67bb7b4449d68a078e4a62e4c9b5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1584&h=578&s=144670&e=png&b=1f1f1f)


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9af30cd751f4dd9af13e4801de63247~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=690&s=140350&e=png&b=1f1f1f)

```javascript
transformControls.showY = false;
```

```javascript
transformControls.showY = true;
```

其实应该在 2D 视图里也可以拖拽，然后在 3D 视图看效果。

我们也在 2D 视图里加一下这些逻辑：

首先初始化的时候传入 updateForniture 方法：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c69c069190d475c9f7eccc6b6f152c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1314&h=612&s=110313&e=png&b=1f1f1f)


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f56f98ee28284e608310c3f707faf063~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1662&h=412&s=103540&e=png&b=1f1f1f)

```javascript
updateFurniture: Action['updateFurniture']
```
然后也加一段同样的 TransformControls 的逻辑：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c192037b9e647b49b20d501f531b0e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1684&h=1438&s=304037&e=png&b=1f1f1f)

```javascript
const transformControls = new TransformControls(camera, renderer.domElement);
transformControls.showY = false;

const transformHelper = transformControls.getHelper();
scene.add(transformHelper);

transformControls.addEventListener('dragging-changed', function (event) {
    controls.enabled = !event.value;
});

transformControls.addEventListener('change', () => {
    const obj = transformControls.object;

    if(obj) {
        if(transformControls.mode === 'translate') {
            updateFurniture(obj.name, 'position',new THREE.Vector3(
                -obj.position.x,
                -obj.position.y,
                -obj.position.z
            ));
        } else if(transformControls.mode === 'rotate'){
            updateFurniture(obj.name, 'rotation', new THREE.Vector3(
                obj.rotation.x,
                obj.rotation.y,
                obj.rotation.z
            ));
        }
    }
});
```
要注意的是，位置是相反的，所以需要取反之后再保存。

处理下点击事件：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d8d8673a7d46c19c527336990f27be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1586&h=1288&s=262298&e=png&b=1f1f1f)

```javascript
renderer.domElement.addEventListener('click', (e) => {
    const y = -((e.offsetY / height) * 2 - 1);
    const x = (e.offsetX / width) * 2 - 1;

    const rayCaster = new THREE.Raycaster();
    rayCaster.setFromCamera(new THREE.Vector2(x, y), camera);

    const furnitures = scene.getObjectByName('furnitures')!;
    const intersections2 = rayCaster.intersectObjects(furnitures.children);

    if(intersections2.length) {
        const obj = intersections2[0].object as any;
        if(obj.target) {
            transformControls.attach(obj.target);
        }
    } else {
        transformControls.detach();
    }
});
```
试下效果：


![2025-07-02 17.19.04.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35dc95dc1d74960945935d0281e1c9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=925420&e=gif&f=36&b=f4f4f4)

然后再处理下旋转。

同样加一个切换 mode 的方法：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3469d99b354944889b485f8640bd9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1422&h=1224&s=218345&e=png&b=1f1f1f)

```javascript
function changeMode(isTranslate: boolean) {
    if(isTranslate) {
        transformControls.mode = 'translate';
        transformControls.showX = true;
        transformControls.showZ = true;
        transformControls.showY = false;
    } else {
        transformControls.mode = 'rotate';
        transformControls.showX = false;
        transformControls.showZ = false;
        transformControls.showY = true;
    }
}
```
加一个 ref 来接收：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58e2ca4c4a674b2197f83428d342a761~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1436&h=480&s=139011&e=png&b=1f1f1f)

```javascript
const changeMode2DRef = useRef<(isTranslate: boolean) => void>(null);
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49a7ddc0e3604bafa368853df7a9d644~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1388&h=554&s=111708&e=png&b=1f1f1f)

```javascript
changeMode2DRef.current = changeMode;
```
调用下：
![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f91415638524271b3edfde38fb07544~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1322&h=988&s=170971&e=png&b=1f1f1f)

```javascript
<Button
    onClick={() => {
        changeModeRef.current?.(true);
        changeMode2DRef.current?.(true);
    }}
    >平移</Button>
<Button
    onClick={() => {
        changeModeRef.current?.(false);
        changeMode2DRef.current?.(false);
    }}
    >旋转</Button>
```
试下效果：


![2025-07-02 17.29.44.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e0795e5de1e47929a394a3acf48e587~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=1222821&e=gif&f=50&b=f3f3f3)

这样，2D 视图的家具渲染、编辑就完成了。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/home-decoration-editor)


## 总结

这节我们在 2D 视图绘制了家具，并且实现了编辑功能。

用同样的数据在 2D 视图里渲染家具，只不过位置因为之前调整墙绘制问题需要设置相反数。

编辑也是用 TransformControls 来实现，只是不需要 y 轴的编辑，在 2D 视图改了数据，会同步更新 3D 视图。

这样，我们就可以在 2D 或者 3D 视图编辑家具位置、旋转角度了。

