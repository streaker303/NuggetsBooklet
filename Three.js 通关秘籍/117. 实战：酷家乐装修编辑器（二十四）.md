上节加了家具列表：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f68bb0ea9c2648789945b5142b6749a4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2042&h=1526&s=1299747&e=png&b=f7f7f7)

这节我们来做把家具拖拽到 3D 场景的功能。

如果直接在 3D 场景中添加家具我们会，就是直接改数据，加一个 furniture。

但问题是位置如何确定呢？

这种就是在拖拽过程中做计算了。

点击的时候，我们能拿到点击位置的 offset，然后计算出在场景中的哪个位置：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67486637854f40aca415d83cecd9478a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1420&h=650&s=158748&e=png&b=1f1f1f)

拖拽也是一样的。

拖动的时候，拿到这个 offset，然后计算出 3D 场景中的位置，在那个位置加一个对应的家具就好了。

这里我们要用到 react 的一个拖拽库 react-dnd

安装下：

```
pnpm install --save react-dnd react-dnd-html5-backend
```

首先在根组件加一个 Provider：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24350053fe124481a02211f7263f04de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1134&h=660&s=127876&e=png&b=1f1f1f)

因为需要从一个组件拖到另一个组件，需要跨组件通信，所以要在最外层加一个 Provider。

```javascript
import { DndProvider } from 'react-dnd'
import { HTML5Backend } from 'react-dnd-html5-backend'
```
```javascript
<DndProvider backend={HTML5Backend}>
    <App />
</DndProvider>
```

然后它的用法是在拖拽的目标上用 useDrag，拖拽到的目标用 useDrop。

我们先把菜单项抽离出单独的组件：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5deb816c5f14aec822ded1443f3409b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158&h=964&s=139443&e=png&b=1f1f1f)

```javascript
interface MenuItemProps {
    imgSrc: string;
    title: string;
}

function MenuItem(props: MenuItemProps) {
    return <Card
        hoverable
        style={{ width: 200, margin: 20 }}
        cover={<img
            width={200}
            src={props.imgSrc}
        />}
    >
        <Meta title={props.title} description="" />
    </Card>
}
```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9668fb36709449b0ae41b79d2877c264~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1248&h=538&s=95354&e=png&b=1f1f1f)

```javascript
<MenuItem imgSrc="./bed.png" title="床"/>
<MenuItem imgSrc="./table.png" title="餐桌"/>
```
然后在这个组件里加 useDrag：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3b90986c9e74b84af03ce4d33c50a40~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=990&s=128403&e=png&b=1f1f1f)

```javascript
function MenuItem(props: MenuItemProps) {

    const ref = useRef(null);

    const [, drag]= useDrag({
        type: '家具'
    });

    useEffect(() => {
        drag(ref);
    }, []);

    return <Card
        hoverable
        style={{ width: 200, margin: 20 }}
        cover={<img
            width={200}
            ref={ref}
            src={props.imgSrc}
        />}
    >
        <Meta title={props.title} description="" />
    </Card>
}
```
把拖动事件绑定在 img 元素上。


![2025-07-20 14.11.37.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/427dff7586564da6ab9f45713890bdbb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=1056882&e=gif&f=22&b=f4f4f4)

现在就可以拖动了。

然后 drop 在哪里呢？

在画布区。

我们加一下 useDrop：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8abcab6e47e4635bf51a99f32a3539a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1296&h=912&s=180684&e=png&b=1f1f1f)

```javascript
const [, drop] = useDrop({
    accept: '家具',
    drop: (item, monitor) => {
        console.log('drop');
    },
})
useEffect(() => {
    const div = document.getElementById('threejs-3d-container');
    drop(div);
}, []);
```
这次我们不用 ref 了，直接根据 id 查找就行。

这里的 accept 和 useDrag 那里的 type 对应才能接收它的 drop。


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b86f43aa5c8b4ad3a269943eb9536172~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=840&h=568&s=54752&e=png&b=1f1f1f)

试一下：


![2025-07-20 14.14.47.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42372b63eb314d9a953cb7c3803d396c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=1382344&e=gif&f=30&b=f8f8f8)

可以看到，现在确实能触发 drop 事件。

然后我们拿到 drop 的地方和元素左上角的距离。



![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55aa6d0706004717ad2f420e613de18e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1362&h=788&s=156522&e=png&b=1f1f1f)

```javascript
const [, drop] = useDrop({
    accept: '家具',
    drop: (item, monitor) => {
        const dom = document.getElementById('threejs-3d-container')!;
        const clientOffset = monitor.getClientOffset();
        const rect = dom.getBoundingClientRect();

        if (clientOffset && rect) {
            const x = clientOffset.x - rect.x;
            const y = clientOffset.y - rect.y;
            console.log(x, y)
        }
    },
})
```
这里就是用 drop 位置到可视区域顶部、左侧的距离，减去所在元素的距离顶部、左侧的距离：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab60c1c92c4f4407aea4c281cdfd8e49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2314&h=1494&s=1526613&e=png&b=f6f6f6)

剩下的就是 drop 位置到元素的顶部、左侧的距离。


![2025-07-20 19.55.12.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0912734f5b34cdc9f51f7a9c67d88a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=2733689&e=gif&f=31&b=f6f6f6)

有了这个位置之后呢？

其实就和点击的处理一模一样。

点击的时候拿到了 offset 就可以用 RasyCaster 来计算从这个位置的射线和哪些物体相交。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c553d99d37a441f92220afd0134952e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1450&h=634&s=153255&e=png&b=1f1f1f)

offset 有了，width、height 也有了，camera 之前也导出了。

那就可以计算添加家具的位置了：

我们要和地板来判断相交位置，把地板也用一个 group 来管理：



![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/802ddf136b6d4154adbc52a80d7b977e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1106&h=408&s=86821&e=png&b=1f1f1f)


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f8b7d81db0240da9179163592e7159d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=804&h=412&s=51905&e=png&b=1f1f1f)

注意，这里改的是 3D 里的，别改成 2D 的了。

```javascript
const floorGroup = new THREE.Group();
floorGroup.name = 'floors';
```
```javascript
floorGroup.add(floor);
```
```javascript
house.add(floorGroup);
```
这样查找就方便了：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/638885608d934268be3568d925990065~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1610&h=1330&s=271801&e=png&b=1f1f1f)

```javascript
const offsetX = clientOffset.x - rect.x;
const offsetY = clientOffset.y - rect.y;

const width = window.innerWidth;
const height = window.innerHeight - 60;

const y = -((offsetY / height) * 2 - 1);
const x = (offsetX / width) * 2 - 1;

const rayCaster = new THREE.Raycaster();
rayCaster.setFromCamera(new THREE.Vector2(x, y), camera3DRef.current!);

const scene3D = scene3DRef.current!;

const floorGroup = scene3D.getObjectByName('floors')!;
const intersections = rayCaster.intersectObjects(floorGroup.children);

if(intersections.length) {
    const point = intersections[0].point;
    console.log(point);
}
```
这里的逻辑和点击时的一样。

就是根据 offset 和 camera 的位置来发射一条射线。

用 RayCaster 的 api 判断和哪些对象相交。

打印下相交的点。


![2025-07-20 20.19.33.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc6659db4a4f42ab9495f84dfdb0d98c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=5310185&e=gif&f=44&b=f8f8f8)

有了位置之后，接下来要做的事情就是在这个位置添加一条家具数据了。

加一个 addFurniture 方法：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcded15472ca4c329871a1d2eeb69409~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1616&h=502&s=101207&e=png&b=1f1f1f)


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d533276106bc45d3a1562818d3ead6f5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1156&h=798&s=108129&e=png&b=1f1f1f)

```javascript
addFurniture(furniture: Furniture): void;
```
```javascript
addFurniture(furniture) {
    set(state => {
        return {
            ...state,
            data: {
                ...state.data,
                furnitures: [
                    ...state.data.furnitures,
                    furniture
                ]
            }
        }
    })
}
```
drop 的时候调用下：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/800976f312e1418f97b148fa83251732~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1378&h=694&s=201485&e=png&b=1f1f1f)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/287860cf6ce24ea0998b968448d254b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1676&h=1078&s=176266&e=png&b=1f1f1f)

```javascript
if(intersections.length) {
    const point = intersections[0].point;

    addFurniture({
        id: 'furniture' + Math.random().toString().slice(2, 8),
        modelUrl: './dining-table.glb',
        position: {
            x: point.x,
            y: 0,
            z: point.z
        },
        rotation: {
            x: 0,
            y: 0,
            z: 0
        }
    });
}
```
试下效果：


![2025-07-25 19.34.21.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7108ac5ddd7046cab0df504f61a88736~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=3075370&e=gif&f=42&b=f4f4f4)

拖过去，然后刷新页面，可以看到确实加了一个家具，但是位置不对。

我们分别来解决下这俩问题。

位置不对的问题，是因为房子移动了一些距离。

去掉这行代码：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/945acf373a424212ab6c695a7b072636~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1286&h=536&s=109702&e=png&b=1f1f1f)

再试试：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/150149219e4a442baa602c9768907cdd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=754&h=808&s=142927&e=png&b=f9f9f9)


![2025-07-25 19.38.06.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0a0e3bef9be4074bac74baba44fb58a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=4358474&e=gif&f=47&b=f9f9f9)

清空数据，然后拖一个家具到那个位置，刷新页面，可以看到家具位置是正确的。

然后再来解决不渲染的问题：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a0944a72a224123937fb110429b06dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1472&h=1280&s=216542&e=png&b=1f1f1f)

这个是因为我们之前判断如果 house 存在，那就更新家具。

但 house 存在也可以能是新添加了家具。

我们加一个 else 就好了：

```javascript
else {
    const gltfLoader = new GLTFLoader();
    const furnitures = houseObj.getObjectByName('furnitures')!;

    gltfLoader.load(furniture.modelUrl, (gltf) => {
        furnitures.add(gltf.scene);

        gltf.scene.scale.setScalar(furniture.modelScale || 1);

        gltf.scene.position.set(
            furniture.position.x,
            furniture.position.y,
            furniture.position.z
        );

        gltf.scene.rotation.x = furniture.rotation.x;
        gltf.scene.rotation.y = furniture.rotation.y;
        gltf.scene.rotation.z = furniture.rotation.z;

        gltf.scene.traverse(obj => {
            (obj as any).target = gltf.scene;
        });
        gltf.scene.name = furniture.id
    });
}
```
试下效果：


![2025-07-25 19.42.20.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/376965e3e0f84da4b77601a1949c446b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568&h=1418&s=3770634&e=gif&f=37&b=f6f6f6)


现在，拖拽家具到目标位置的功能就完成了。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/home-decoration-editor)

## 总结

这节我们实现了拖拽家具到房子任意位置的功能。

首先，我们用 react-dnd 这个拖拽库来实现拖拽，在要拖拽的目标上用 useDrag，拖拽到的目标用 useDrop。

我们主要是要拿到拖拽家具 img 到了 canvas 的哪个位置，拿到 offset

有了 offset 就可以用之前处理点击时的 RayCaster 来找到交点，然后在交点位置加一个家具。

现在还有一些小问题，下节我们继续完善。
