上节把家具的平移、旋转等编辑功能实现了：

![2025-06-29 14.00.21.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84ec630392134d519bdefcbe85daad79~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=2340138&e=gif&f=50&b=f4f4f4)

这节我们把编辑后的 position、rotation 存入 store 中，并且在 2d 视图中把它画出来。

因为后面可能添加多个，我们给每个家具一个唯一的 id：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/104c83eab0554114b134b738841acfe5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=1112&s=124872&e=png&b=1f1f1f)



![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f121bc985b79461dbd0de9ce4b096bbb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=968&h=1028&s=116330&e=png&b=1f1f1f)

渲染家具的时候设置 name：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/858b3b5a7e514c409485e1f4ac27899f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1160&h=870&s=140754&e=png&b=1f1f1f)

```javascript
gltf.scene.name = furniture.id
```
这样更新的时候就可以根据 id 查找了。

添加一个更新家具的方法：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9506568c2e3469183b74d70a270bc7e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1704&h=1366&s=237216&e=png&b=1f1f1f)

```javascript
export interface Action {
    setData(data: State['data']): void;
    updateFurniture(id: string, type: 'position' | 'rotation', info: Vector3): void;
}
```
```javascript
updateFurniture(id, type, info) {
    set(state => {
        return {
            ...state,
            data: {
                ...state.data,
                furnitures: state.data.furnitures.map(item => {
                    if(item.id === id) {
                        if(type === 'position') {
                            item.position.x = info.x;
                            item.position.y = info.y;
                            item.position.z = info.z;
                        } else {
                            item.rotation.x = info.x;
                            item.rotation.y = info.y;
                            item.rotation.z = info.z;
                        }
                    }
                    return item;
                })
            }
        }
    })
}
```
然后改变位置、旋转角度的时候更新下 store：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45cb975605a140b1a3cdaf9baadecea3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1810&h=806&s=188926&e=png&b=1f1f1f)


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58dfdd4ce848491190b0a9fbd46e9c53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1064&h=466&s=78899&e=png&b=1f1f1f)

把这个更新方法传入 init3D

```javascript
updateFurniture: Action['updateFurniture']
```
change 的时候调用下来更新 store：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7d000408f9473090f2acc30c88e2a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1550&h=942&s=194792&e=png&b=1f1f1f)

光这样还不行，现在有个严重的问题。

因为 data 一变，就会删除整个场景：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3b3c3a43cc54349bc54db14ef8a6a71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1132&h=840&s=152095&e=png&b=1f1f1f)

我们得区分这是改变家具而不是清空数据：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09995d586b4f43898305dd4f8a57fa26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1132&h=960&s=167826&e=png&b=1f1f1f)

加个判断就好了

```javascript
if(data.walls.length) {
    return;
}
```
同样，渲染 house 的时候也要判断，如果已经有了，那就是更新家具：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaa8dba616b249b9b48544cee7cc1dfe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1270&h=1232&s=204190&e=png&b=1f1f1f)

```javascript
const houseObj = scene.getObjectByName('house')!;
if(houseObj) {
    data.furnitures.forEach(furniture => {
        const obj = houseObj.getObjectByName(furniture.id);

        if(obj) {
            obj.position.set(
                furniture.position.x,
                furniture.position.y,
                furniture.position.z
            );

            obj.rotation.x = furniture.rotation.x;
            obj.rotation.y = furniture.rotation.y;
            obj.rotation.z = furniture.rotation.z;
        }
    })
    return;
}
```

为了观察 json 是不是变了，我们把它渲染出来：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7fee70ddf594ea9b16adec37f9ee7d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1244&h=904&s=151451&e=png&b=1f1f1f)

```javascript
const { data } = useHouseStore();
```
```javascript
<pre>
    {JSON.stringify(data.furnitures, null, 4)}
</pre>
```
试一下：


![2025-06-29 20.52.54.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c7066df93ab47048b35fad691d5efac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=2115798&e=gif&f=50&b=ecf9fa)

平移和旋转家具的时候，可以看到 store 里的数据确实改变了。

这样，编辑家具到保存到 json 里就都完成了。

但现在编辑的数据刷新就没了：

![2025-06-29 20.56.55.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9beeb91634d40df8dc09db7490c269c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=780971&e=gif&f=34&b=f4f4f4)

我们加一下 store 的持久化：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00213a04d0ab43c996ebb1cb58962841~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=452&s=88348&e=png&b=1f1f1f)


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/745ac9fc917640d7a2fb5ebb76cde445~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1384&h=640&s=114679&e=png&b=1f1f1f)

```javascript
const stateCreator: StateCreator<State & Action> = (set, get) => {
};

const useHouseStore = create<State & Action>()(persist(stateCreator, {
    name: 'house'
}));
```
试下效果：


![2025-06-29 21.02.43.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fb3bbf2b2df4eda90102a3449d0ee62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2362&h=1398&s=1097552&e=gif&f=43&b=f4f4f4)

现在编辑完刷新页面依然保存着编辑后的结果。

在 localStorage 里也能看到保存的数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3de61264837b4f66b9172a1966ea7b08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1302&h=1100&s=187286&e=png&b=fefefe)

这样，数据持久化就完成了。

>案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/threejs-course-code/tree/main/home-decoration-editor)

## 总结

这节我们做了编辑结果保存到 store 的功能。

我们在 store 添加了一个更新家具信息的方法，给家具一个 id。

改变家具位置、角度的时候调用这个方法来更新 json 里的家具信息。

要注意的是之前清空数据、渲染房屋都是监听 data 的变化，改了家具也会改 data，会不断触发清空数据，所以我们要处理下，判断出这种情况。

家具编辑的结果保存好后，下节我们把家具同步渲染到 2D 视图。

